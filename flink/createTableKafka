Administration Nifi: https://localhost:8443/nifi/
KafDrop: https://localhost:8443/nifi/
Flink: http://localhost:8085/
Kibana: http://localhost:5601/ (bien penser Ã  ajouter le remote cluster elasticsearch:5300)




docker exec -ti flink-jobmanager sql-client.sh

DROP TABLE KafkaTable;
CREATE TABLE KafkaTable (
  `meterId` STRING,
  `meterValue` STRING,
  corrMeterValue as cast(`meterValue` as Double),
  `meterTimestamp` STRING,
  ts as to_timestamp(from_unixtime(cast(floor(cast(`meterTimestamp` as Double)/1000) as Integer))),
  WATERMARK FOR ts AS ts - INTERVAL '5' SECOND,
  proctime as PROCTIME()
) WITH (
  'connector' = 'kafka',
  'topic' = 'test-topic',
  'properties.bootstrap.servers' = 'kafka:9092',
  'properties.group.id' = 'testGroup',
  'scan.startup.mode' = 'earliest-offset',
  'format' = 'json',
  'json.fail-on-missing-field' = 'false',
  'json.ignore-parse-errors' = 'true'
);

DROP TABLE meterValuesElastic;
CREATE TABLE meterValuesElastic (
    `meterId` STRING,
    `tsMinute` TIMESTAMP,
    `meterValue` DOUBLE
) WITH (
    'connector' = 'elasticsearch-7', -- using elasticsearch connector
    'hosts' = 'http://elasticsearch:9200',  -- elasticsearch address
    'index' = 'meter_values_per_minute'  -- elasticsearch index name, similar to database table name
);

INSERT INTO meterValuesElastic(meterId, tsMinute,meterValue)
select meterId
, TUMBLE_START(ts, INTERVAL '1' MINUTE) as tsd
, avg(corrMeterValue) as avgMeterValue
from KafkaTable
GROUP BY meterId, TUMBLE(ts, INTERVAL '1' MINUTE);

CREATE TABLE MeterReference (
  ID_METER STRING,
  METER_NAME STRING
) WITH (
   'connector' = 'jdbc',
   'url' = 'jdbc:postgresql://datareference:5432/referencedata',
   'username' = 'postgres',
   'password' = 'password', 
   'table-name' = 'METER'
);

SELECT k.meterId, k.corrMeterValue, r.METER_NAME
FROM KafkaTable k 
LEFT JOIN MeterReference r ON k.meterId = r.ID_METER;

-------------------------------

Dans Kibana, scripted field: 

String myDate = doc["tsMinute.keyword"].value + 'Z';
DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ssVV");
ZonedDateTime zdt = ZonedDateTime.parse(myDate, dtf);
return zdt;

--------------------------------